// This file was auto-generated by Fern from our API Definition.

import * as phenoml from "../../../src/api/index";
import { phenomlClient } from "../../../src/Client";
import { mockServerPool } from "../../mock-server/MockServerPool";

describe("Agent", () => {
    test("create (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = { name: "name", prompts: ["prompt_123", "prompt_456"], provider: "provider" };
        const rawResponseBody = {
            success: true,
            message: "Agent created successfully",
            data: {
                id: "agent_123",
                name: "Medical Assistant",
                description: "An AI assistant for medical information processing",
                prompts: ["prompt_123", "prompt_456"],
                tools: ["mcp_server_123", "mcp_server_456"],
                workflows: ["workflow_123", "workflow_456"],
                tags: ["medical", "fhir"],
                provider: "provider",
            },
        };
        server
            .mockEndpoint()
            .post("/agent/create")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.agent.create({
            name: "name",
            prompts: ["prompt_123", "prompt_456"],
            provider: "provider",
        });
        expect(response).toEqual({
            success: true,
            message: "Agent created successfully",
            data: {
                id: "agent_123",
                name: "Medical Assistant",
                description: "An AI assistant for medical information processing",
                prompts: ["prompt_123", "prompt_456"],
                tools: ["mcp_server_123", "mcp_server_456"],
                workflows: ["workflow_123", "workflow_456"],
                tags: ["medical", "fhir"],
                provider: "provider",
            },
        });
    });

    test("create (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = { name: "name", prompts: ["prompts", "prompts"], provider: "provider" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/agent/create")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.agent.create({
                name: "name",
                prompts: ["prompts", "prompts"],
                provider: "provider",
            });
        }).rejects.toThrow(phenoml.agent.BadRequestError);
    });

    test("create (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = { name: "name", prompts: ["prompts", "prompts"], provider: "provider" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/agent/create")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.agent.create({
                name: "name",
                prompts: ["prompts", "prompts"],
                provider: "provider",
            });
        }).rejects.toThrow(phenoml.agent.UnauthorizedError);
    });

    test("create (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = { name: "name", prompts: ["prompts", "prompts"], provider: "provider" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/agent/create")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.agent.create({
                name: "name",
                prompts: ["prompts", "prompts"],
                provider: "provider",
            });
        }).rejects.toThrow(phenoml.agent.ForbiddenError);
    });

    test("create (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = { name: "name", prompts: ["prompts", "prompts"], provider: "provider" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/agent/create")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.agent.create({
                name: "name",
                prompts: ["prompts", "prompts"],
                provider: "provider",
            });
        }).rejects.toThrow(phenoml.agent.InternalServerError);
    });

    test("list (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = {
            success: true,
            message: "Agents retrieved successfully",
            agents: [
                {
                    id: "agent_123",
                    name: "Medical Assistant",
                    description: "An AI assistant for medical information processing",
                    prompts: ["prompt_123", "prompt_456"],
                    tools: ["mcp_server_123", "mcp_server_456"],
                    workflows: ["workflow_123", "workflow_456"],
                    tags: ["medical", "fhir"],
                    provider: "provider",
                },
            ],
        };
        server.mockEndpoint().get("/agent/list").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.agent.list({
            tags: "tags",
        });
        expect(response).toEqual({
            success: true,
            message: "Agents retrieved successfully",
            agents: [
                {
                    id: "agent_123",
                    name: "Medical Assistant",
                    description: "An AI assistant for medical information processing",
                    prompts: ["prompt_123", "prompt_456"],
                    tools: ["mcp_server_123", "mcp_server_456"],
                    workflows: ["workflow_123", "workflow_456"],
                    tags: ["medical", "fhir"],
                    provider: "provider",
                },
            ],
        });
    });

    test("list (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/agent/list").respondWith().statusCode(401).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.agent.list();
        }).rejects.toThrow(phenoml.agent.UnauthorizedError);
    });

    test("list (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/agent/list").respondWith().statusCode(403).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.agent.list();
        }).rejects.toThrow(phenoml.agent.ForbiddenError);
    });

    test("list (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/agent/list").respondWith().statusCode(500).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.agent.list();
        }).rejects.toThrow(phenoml.agent.InternalServerError);
    });

    test("get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = {
            success: true,
            message: "Agent created successfully",
            data: {
                id: "agent_123",
                name: "Medical Assistant",
                description: "An AI assistant for medical information processing",
                prompts: ["prompt_123", "prompt_456"],
                tools: ["mcp_server_123", "mcp_server_456"],
                workflows: ["workflow_123", "workflow_456"],
                tags: ["medical", "fhir"],
                provider: "provider",
            },
        };
        server.mockEndpoint().get("/agent/id").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.agent.get("id");
        expect(response).toEqual({
            success: true,
            message: "Agent created successfully",
            data: {
                id: "agent_123",
                name: "Medical Assistant",
                description: "An AI assistant for medical information processing",
                prompts: ["prompt_123", "prompt_456"],
                tools: ["mcp_server_123", "mcp_server_456"],
                workflows: ["workflow_123", "workflow_456"],
                tags: ["medical", "fhir"],
                provider: "provider",
            },
        });
    });

    test("get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/agent/id").respondWith().statusCode(401).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.agent.get("id");
        }).rejects.toThrow(phenoml.agent.UnauthorizedError);
    });

    test("get (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/agent/id").respondWith().statusCode(403).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.agent.get("id");
        }).rejects.toThrow(phenoml.agent.ForbiddenError);
    });

    test("get (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/agent/id").respondWith().statusCode(404).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.agent.get("id");
        }).rejects.toThrow(phenoml.agent.NotFoundError);
    });

    test("get (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/agent/id").respondWith().statusCode(500).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.agent.get("id");
        }).rejects.toThrow(phenoml.agent.InternalServerError);
    });

    test("update (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = { name: "name", prompts: ["prompt_123", "prompt_456"], provider: "provider" };
        const rawResponseBody = {
            success: true,
            message: "Agent created successfully",
            data: {
                id: "agent_123",
                name: "Medical Assistant",
                description: "An AI assistant for medical information processing",
                prompts: ["prompt_123", "prompt_456"],
                tools: ["mcp_server_123", "mcp_server_456"],
                workflows: ["workflow_123", "workflow_456"],
                tags: ["medical", "fhir"],
                provider: "provider",
            },
        };
        server
            .mockEndpoint()
            .put("/agent/id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.agent.update("id", {
            name: "name",
            prompts: ["prompt_123", "prompt_456"],
            provider: "provider",
        });
        expect(response).toEqual({
            success: true,
            message: "Agent created successfully",
            data: {
                id: "agent_123",
                name: "Medical Assistant",
                description: "An AI assistant for medical information processing",
                prompts: ["prompt_123", "prompt_456"],
                tools: ["mcp_server_123", "mcp_server_456"],
                workflows: ["workflow_123", "workflow_456"],
                tags: ["medical", "fhir"],
                provider: "provider",
            },
        });
    });

    test("update (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = { name: "name", prompts: ["prompts", "prompts"], provider: "provider" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .put("/agent/id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.agent.update("id", {
                name: "name",
                prompts: ["prompts", "prompts"],
                provider: "provider",
            });
        }).rejects.toThrow(phenoml.agent.BadRequestError);
    });

    test("update (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = { name: "name", prompts: ["prompts", "prompts"], provider: "provider" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .put("/agent/id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.agent.update("id", {
                name: "name",
                prompts: ["prompts", "prompts"],
                provider: "provider",
            });
        }).rejects.toThrow(phenoml.agent.UnauthorizedError);
    });

    test("update (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = { name: "name", prompts: ["prompts", "prompts"], provider: "provider" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .put("/agent/id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.agent.update("id", {
                name: "name",
                prompts: ["prompts", "prompts"],
                provider: "provider",
            });
        }).rejects.toThrow(phenoml.agent.ForbiddenError);
    });

    test("update (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = { name: "name", prompts: ["prompts", "prompts"], provider: "provider" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .put("/agent/id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.agent.update("id", {
                name: "name",
                prompts: ["prompts", "prompts"],
                provider: "provider",
            });
        }).rejects.toThrow(phenoml.agent.NotFoundError);
    });

    test("update (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = { name: "name", prompts: ["prompts", "prompts"], provider: "provider" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .put("/agent/id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.agent.update("id", {
                name: "name",
                prompts: ["prompts", "prompts"],
                provider: "provider",
            });
        }).rejects.toThrow(phenoml.agent.InternalServerError);
    });

    test("delete (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { success: true, message: "Agent deleted successfully" };
        server.mockEndpoint().delete("/agent/id").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.agent.delete("id");
        expect(response).toEqual({
            success: true,
            message: "Agent deleted successfully",
        });
    });

    test("delete (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().delete("/agent/id").respondWith().statusCode(401).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.agent.delete("id");
        }).rejects.toThrow(phenoml.agent.UnauthorizedError);
    });

    test("delete (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().delete("/agent/id").respondWith().statusCode(403).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.agent.delete("id");
        }).rejects.toThrow(phenoml.agent.ForbiddenError);
    });

    test("delete (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().delete("/agent/id").respondWith().statusCode(404).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.agent.delete("id");
        }).rejects.toThrow(phenoml.agent.NotFoundError);
    });

    test("delete (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().delete("/agent/id").respondWith().statusCode(500).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.agent.delete("id");
        }).rejects.toThrow(phenoml.agent.InternalServerError);
    });

    test("patch (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = [
            { op: "replace", path: "/name", value: "Updated Agent Name" },
            { op: "add", path: "/tags/-", value: "new-tag" },
            { op: "remove", path: "/description" },
        ];
        const rawResponseBody = {
            success: true,
            message: "Agent created successfully",
            data: {
                id: "agent_123",
                name: "Medical Assistant",
                description: "An AI assistant for medical information processing",
                prompts: ["prompt_123", "prompt_456"],
                tools: ["mcp_server_123", "mcp_server_456"],
                workflows: ["workflow_123", "workflow_456"],
                tags: ["medical", "fhir"],
                provider: "provider",
            },
        };
        server
            .mockEndpoint()
            .patch("/agent/id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.agent.patch("id", [
            {
                op: "replace",
                path: "/name",
                value: "Updated Agent Name",
            },
            {
                op: "add",
                path: "/tags/-",
                value: "new-tag",
            },
            {
                op: "remove",
                path: "/description",
            },
        ]);
        expect(response).toEqual({
            success: true,
            message: "Agent created successfully",
            data: {
                id: "agent_123",
                name: "Medical Assistant",
                description: "An AI assistant for medical information processing",
                prompts: ["prompt_123", "prompt_456"],
                tools: ["mcp_server_123", "mcp_server_456"],
                workflows: ["workflow_123", "workflow_456"],
                tags: ["medical", "fhir"],
                provider: "provider",
            },
        });
    });

    test("patch (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = [
            { op: "add", path: "path" },
            { op: "add", path: "path" },
        ];
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/agent/id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.agent.patch("id", [
                {
                    op: "add",
                    path: "path",
                },
                {
                    op: "add",
                    path: "path",
                },
            ]);
        }).rejects.toThrow(phenoml.agent.BadRequestError);
    });

    test("patch (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = [
            { op: "add", path: "path" },
            { op: "add", path: "path" },
        ];
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/agent/id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.agent.patch("id", [
                {
                    op: "add",
                    path: "path",
                },
                {
                    op: "add",
                    path: "path",
                },
            ]);
        }).rejects.toThrow(phenoml.agent.UnauthorizedError);
    });

    test("patch (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = [
            { op: "add", path: "path" },
            { op: "add", path: "path" },
        ];
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/agent/id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.agent.patch("id", [
                {
                    op: "add",
                    path: "path",
                },
                {
                    op: "add",
                    path: "path",
                },
            ]);
        }).rejects.toThrow(phenoml.agent.ForbiddenError);
    });

    test("patch (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = [
            { op: "add", path: "path" },
            { op: "add", path: "path" },
        ];
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/agent/id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.agent.patch("id", [
                {
                    op: "add",
                    path: "path",
                },
                {
                    op: "add",
                    path: "path",
                },
            ]);
        }).rejects.toThrow(phenoml.agent.NotFoundError);
    });

    test("patch (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = [
            { op: "add", path: "path" },
            { op: "add", path: "path" },
        ];
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/agent/id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.agent.patch("id", [
                {
                    op: "add",
                    path: "path",
                },
                {
                    op: "add",
                    path: "path",
                },
            ]);
        }).rejects.toThrow(phenoml.agent.InternalServerError);
    });

    test("chat (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = { message: "What is the patient's current condition?", agent_id: "agent-123" };
        const rawResponseBody = {
            response: "I'll create a patient record for John Doe with diabetes. Let me process that information...",
            success: true,
            message: "Chat response generated successfully",
            session_id: "session_123",
        };
        server
            .mockEndpoint()
            .post("/agent/chat")
            .header("X-Phenoml-On-Behalf-Of", "Patient/550e8400-e29b-41d4-a716-446655440000")
            .header(
                "X-Phenoml-Fhir-Provider",
                "550e8400-e29b-41d4-a716-446655440000:eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c...",
            )
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.agent.chat({
            "X-Phenoml-On-Behalf-Of": "Patient/550e8400-e29b-41d4-a716-446655440000",
            "X-Phenoml-Fhir-Provider":
                "550e8400-e29b-41d4-a716-446655440000:eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c...",
            message: "What is the patient's current condition?",
            agent_id: "agent-123",
        });
        expect(response).toEqual({
            response: "I'll create a patient record for John Doe with diabetes. Let me process that information...",
            success: true,
            message: "Chat response generated successfully",
            session_id: "session_123",
        });
    });

    test("chat (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = { message: "message", agent_id: "agent_id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/agent/chat")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.agent.chat({
                message: "message",
                agent_id: "agent_id",
            });
        }).rejects.toThrow(phenoml.agent.BadRequestError);
    });

    test("chat (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = { message: "message", agent_id: "agent_id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/agent/chat")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.agent.chat({
                message: "message",
                agent_id: "agent_id",
            });
        }).rejects.toThrow(phenoml.agent.UnauthorizedError);
    });

    test("chat (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = { message: "message", agent_id: "agent_id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/agent/chat")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.agent.chat({
                message: "message",
                agent_id: "agent_id",
            });
        }).rejects.toThrow(phenoml.agent.ForbiddenError);
    });

    test("chat (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = { message: "message", agent_id: "agent_id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/agent/chat")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.agent.chat({
                message: "message",
                agent_id: "agent_id",
            });
        }).rejects.toThrow(phenoml.agent.InternalServerError);
    });

    test("getChatMessages (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = {
            messages: [
                {
                    id: "message_123",
                    session_id: "session_123",
                    role: "user",
                    content: "Hello, how are you?",
                    created: "2021-01-01T00:00:00Z",
                    updated: "2021-01-01T00:00:00Z",
                    function_name: "get_patient_info",
                    function_args: { patient_id: "123" },
                    function_result: { name: "John Doe" },
                    message_order: 1,
                },
            ],
            total: 10,
            session_id: "session_123",
        };
        server
            .mockEndpoint()
            .get("/agent/chat/messages")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.agent.getChatMessages({
            chat_session_id: "chat_session_id",
            num_messages: 1,
            role: "user",
            order: "asc",
        });
        expect(response).toEqual({
            messages: [
                {
                    id: "message_123",
                    session_id: "session_123",
                    role: "user",
                    content: "Hello, how are you?",
                    created: "2021-01-01T00:00:00Z",
                    updated: "2021-01-01T00:00:00Z",
                    function_name: "get_patient_info",
                    function_args: {
                        patient_id: "123",
                    },
                    function_result: {
                        name: "John Doe",
                    },
                    message_order: 1,
                },
            ],
            total: 10,
            session_id: "session_123",
        });
    });

    test("getChatMessages (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/agent/chat/messages")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.agent.getChatMessages({
                chat_session_id: "chat_session_id",
            });
        }).rejects.toThrow(phenoml.agent.UnauthorizedError);
    });

    test("getChatMessages (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/agent/chat/messages")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.agent.getChatMessages({
                chat_session_id: "chat_session_id",
            });
        }).rejects.toThrow(phenoml.agent.ForbiddenError);
    });

    test("getChatMessages (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/agent/chat/messages")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.agent.getChatMessages({
                chat_session_id: "chat_session_id",
            });
        }).rejects.toThrow(phenoml.agent.InternalServerError);
    });
});
