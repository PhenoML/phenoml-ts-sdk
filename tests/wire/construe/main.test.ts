// This file was auto-generated by Fern from our API Definition.

import * as phenoml from "../../../src/api/index";
import { phenomlClient } from "../../../src/Client";
import { mockServerPool } from "../../mock-server/MockServerPool";

describe("Construe", () => {
    test("uploadCodeSystem (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = {
            format: "csv",
            name: "CUSTOM_CODES",
            version: "1.0",
            file: "file",
            code_col: "code",
            desc_col: "description",
        };
        const rawResponseBody = { status: "success" };
        server
            .mockEndpoint()
            .post("/construe/upload")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.construe.uploadCodeSystem({
            format: "csv",
            name: "CUSTOM_CODES",
            version: "1.0",
            file: "file",
            code_col: "code",
            desc_col: "description",
        });
        expect(response).toEqual({
            status: "success",
        });
    });

    test("uploadCodeSystem (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = {
            format: "csv",
            name: "name",
            version: "version",
            file: "file",
            code_col: "code_col",
            desc_col: "desc_col",
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/construe/upload")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.uploadCodeSystem({
                format: "csv",
                name: "name",
                version: "version",
                file: "file",
                code_col: "code_col",
                desc_col: "desc_col",
            });
        }).rejects.toThrow(phenoml.construe.BadRequestError);
    });

    test("uploadCodeSystem (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = {
            format: "csv",
            name: "name",
            version: "version",
            file: "file",
            code_col: "code_col",
            desc_col: "desc_col",
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/construe/upload")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.uploadCodeSystem({
                format: "csv",
                name: "name",
                version: "version",
                file: "file",
                code_col: "code_col",
                desc_col: "desc_col",
            });
        }).rejects.toThrow(phenoml.construe.UnauthorizedError);
    });

    test("uploadCodeSystem (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = {
            format: "csv",
            name: "name",
            version: "version",
            file: "file",
            code_col: "code_col",
            desc_col: "desc_col",
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/construe/upload")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.uploadCodeSystem({
                format: "csv",
                name: "name",
                version: "version",
                file: "file",
                code_col: "code_col",
                desc_col: "desc_col",
            });
        }).rejects.toThrow(phenoml.construe.ForbiddenError);
    });

    test("uploadCodeSystem (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = {
            format: "csv",
            name: "name",
            version: "version",
            file: "file",
            code_col: "code_col",
            desc_col: "desc_col",
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/construe/upload")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(409)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.uploadCodeSystem({
                format: "csv",
                name: "name",
                version: "version",
                file: "file",
                code_col: "code_col",
                desc_col: "desc_col",
            });
        }).rejects.toThrow(phenoml.construe.ConflictError);
    });

    test("uploadCodeSystem (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = {
            format: "csv",
            name: "name",
            version: "version",
            file: "file",
            code_col: "code_col",
            desc_col: "desc_col",
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/construe/upload")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(424)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.uploadCodeSystem({
                format: "csv",
                name: "name",
                version: "version",
                file: "file",
                code_col: "code_col",
                desc_col: "desc_col",
            });
        }).rejects.toThrow(phenoml.construe.FailedDependencyError);
    });

    test("uploadCodeSystem (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = {
            format: "csv",
            name: "name",
            version: "version",
            file: "file",
            code_col: "code_col",
            desc_col: "desc_col",
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/construe/upload")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.uploadCodeSystem({
                format: "csv",
                name: "name",
                version: "version",
                file: "file",
                code_col: "code_col",
                desc_col: "desc_col",
            });
        }).rejects.toThrow(phenoml.construe.InternalServerError);
    });

    test("extractCodes (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = {
            text: "Patient is a 14-year-old female, previously healthy, who is here for evaluation of abnormal renal ultrasound with atrophic right kidney",
        };
        const rawResponseBody = {
            system: { name: "SNOMED_CT_US_LITE", version: "20240901" },
            codes: [
                {
                    code: "195967001",
                    description: "Asthma",
                    valid: true,
                    longDescription: "longDescription",
                    rationale: "rationale",
                    is_ancestor: true,
                    citations: [{ text: "Patient has type 2 diabetes", begin_offset: 0, end_offset: 27 }],
                },
            ],
        };
        server
            .mockEndpoint()
            .post("/construe/extract")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.construe.extractCodes({
            text: "Patient is a 14-year-old female, previously healthy, who is here for evaluation of abnormal renal ultrasound with atrophic right kidney",
        });
        expect(response).toEqual({
            system: {
                name: "SNOMED_CT_US_LITE",
                version: "20240901",
            },
            codes: [
                {
                    code: "195967001",
                    description: "Asthma",
                    valid: true,
                    longDescription: "longDescription",
                    rationale: "rationale",
                    is_ancestor: true,
                    citations: [
                        {
                            text: "Patient has type 2 diabetes",
                            begin_offset: 0,
                            end_offset: 27,
                        },
                    ],
                },
            ],
        });
    });

    test("extractCodes (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = { text: "text" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/construe/extract")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.extractCodes({
                text: "text",
            });
        }).rejects.toThrow(phenoml.construe.BadRequestError);
    });

    test("extractCodes (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = { text: "text" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/construe/extract")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.extractCodes({
                text: "text",
            });
        }).rejects.toThrow(phenoml.construe.UnauthorizedError);
    });

    test("extractCodes (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = { text: "text" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/construe/extract")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(424)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.extractCodes({
                text: "text",
            });
        }).rejects.toThrow(phenoml.construe.FailedDependencyError);
    });

    test("extractCodes (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = { text: "text" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/construe/extract")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.extractCodes({
                text: "text",
            });
        }).rejects.toThrow(phenoml.construe.InternalServerError);
    });

    test("listAvailableCodeSystems (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { systems: [{ name: "ICD-10-CM", version: "2025", code_count: 72750, builtin: true }] };
        server
            .mockEndpoint()
            .get("/construe/codes/systems")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.construe.listAvailableCodeSystems();
        expect(response).toEqual({
            systems: [
                {
                    name: "ICD-10-CM",
                    version: "2025",
                    code_count: 72750,
                    builtin: true,
                },
            ],
        });
    });

    test("listAvailableCodeSystems (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/construe/codes/systems")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.listAvailableCodeSystems();
        }).rejects.toThrow(phenoml.construe.UnauthorizedError);
    });

    test("listAvailableCodeSystems (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/construe/codes/systems")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.listAvailableCodeSystems();
        }).rejects.toThrow(phenoml.construe.InternalServerError);
    });

    test("getCodeSystemDetail (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = {
            name: "ICD-10-CM",
            version: "2025",
            code_count: 72750,
            builtin: true,
            status: "processing",
            created_at: "2024-01-15T09:30:00Z",
            updated_at: "2024-01-15T09:30:00Z",
        };
        server
            .mockEndpoint()
            .get("/construe/codes/systems/ICD-10-CM")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.construe.getCodeSystemDetail("ICD-10-CM", {
            version: "2025",
        });
        expect(response).toEqual({
            name: "ICD-10-CM",
            version: "2025",
            code_count: 72750,
            builtin: true,
            status: "processing",
            created_at: "2024-01-15T09:30:00Z",
            updated_at: "2024-01-15T09:30:00Z",
        });
    });

    test("getCodeSystemDetail (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/construe/codes/systems/codesystem")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.getCodeSystemDetail("codesystem");
        }).rejects.toThrow(phenoml.construe.BadRequestError);
    });

    test("getCodeSystemDetail (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/construe/codes/systems/codesystem")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.getCodeSystemDetail("codesystem");
        }).rejects.toThrow(phenoml.construe.UnauthorizedError);
    });

    test("getCodeSystemDetail (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/construe/codes/systems/codesystem")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.getCodeSystemDetail("codesystem");
        }).rejects.toThrow(phenoml.construe.NotFoundError);
    });

    test("getCodeSystemDetail (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/construe/codes/systems/codesystem")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.getCodeSystemDetail("codesystem");
        }).rejects.toThrow(phenoml.construe.InternalServerError);
    });

    test("deleteCustomCodeSystem (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { message: "code system deleted successfully" };
        server
            .mockEndpoint()
            .delete("/construe/codes/systems/CUSTOM_CODES")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.construe.deleteCustomCodeSystem("CUSTOM_CODES", {
            version: "version",
        });
        expect(response).toEqual({
            message: "code system deleted successfully",
        });
    });

    test("deleteCustomCodeSystem (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/construe/codes/systems/codesystem")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.deleteCustomCodeSystem("codesystem");
        }).rejects.toThrow(phenoml.construe.BadRequestError);
    });

    test("deleteCustomCodeSystem (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/construe/codes/systems/codesystem")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.deleteCustomCodeSystem("codesystem");
        }).rejects.toThrow(phenoml.construe.UnauthorizedError);
    });

    test("deleteCustomCodeSystem (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/construe/codes/systems/codesystem")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.deleteCustomCodeSystem("codesystem");
        }).rejects.toThrow(phenoml.construe.ForbiddenError);
    });

    test("deleteCustomCodeSystem (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/construe/codes/systems/codesystem")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.deleteCustomCodeSystem("codesystem");
        }).rejects.toThrow(phenoml.construe.NotFoundError);
    });

    test("deleteCustomCodeSystem (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/construe/codes/systems/codesystem")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.deleteCustomCodeSystem("codesystem");
        }).rejects.toThrow(phenoml.construe.InternalServerError);
    });

    test("listCodesInACodeSystem (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = {
            system: { name: "ICD-10-CM", version: "2025" },
            codes: [
                {
                    code: "E11.65",
                    description: "Type 2 diabetes mellitus with hyperglycemia",
                    definition: "definition",
                },
            ],
            next_cursor: "next_cursor",
            has_more: true,
        };
        server
            .mockEndpoint()
            .get("/construe/codes/ICD-10-CM")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.construe.listCodesInACodeSystem("ICD-10-CM", {
            version: "2025",
            cursor: "cursor",
            limit: 1,
        });
        expect(response).toEqual({
            system: {
                name: "ICD-10-CM",
                version: "2025",
            },
            codes: [
                {
                    code: "E11.65",
                    description: "Type 2 diabetes mellitus with hyperglycemia",
                    definition: "definition",
                },
            ],
            next_cursor: "next_cursor",
            has_more: true,
        });
    });

    test("listCodesInACodeSystem (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/construe/codes/codesystem")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.listCodesInACodeSystem("codesystem");
        }).rejects.toThrow(phenoml.construe.BadRequestError);
    });

    test("listCodesInACodeSystem (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/construe/codes/codesystem")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.listCodesInACodeSystem("codesystem");
        }).rejects.toThrow(phenoml.construe.UnauthorizedError);
    });

    test("listCodesInACodeSystem (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/construe/codes/codesystem")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.listCodesInACodeSystem("codesystem");
        }).rejects.toThrow(phenoml.construe.NotFoundError);
    });

    test("listCodesInACodeSystem (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/construe/codes/codesystem")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.listCodesInACodeSystem("codesystem");
        }).rejects.toThrow(phenoml.construe.InternalServerError);
    });

    test("getASpecificCode (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = {
            system: { name: "ICD-10-CM", version: "2025" },
            code: "E11.65",
            description: "Type 2 diabetes mellitus with hyperglycemia",
            definition: "definition",
        };
        server
            .mockEndpoint()
            .get("/construe/codes/ICD-10-CM/E11.65")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.construe.getASpecificCode("ICD-10-CM", "E11.65", {
            version: "version",
        });
        expect(response).toEqual({
            system: {
                name: "ICD-10-CM",
                version: "2025",
            },
            code: "E11.65",
            description: "Type 2 diabetes mellitus with hyperglycemia",
            definition: "definition",
        });
    });

    test("getASpecificCode (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/construe/codes/codesystem/codeID")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.getASpecificCode("codesystem", "codeID");
        }).rejects.toThrow(phenoml.construe.BadRequestError);
    });

    test("getASpecificCode (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/construe/codes/codesystem/codeID")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.getASpecificCode("codesystem", "codeID");
        }).rejects.toThrow(phenoml.construe.UnauthorizedError);
    });

    test("getASpecificCode (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/construe/codes/codesystem/codeID")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.getASpecificCode("codesystem", "codeID");
        }).rejects.toThrow(phenoml.construe.NotFoundError);
    });

    test("getASpecificCode (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/construe/codes/codesystem/codeID")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.getASpecificCode("codesystem", "codeID");
        }).rejects.toThrow(phenoml.construe.InternalServerError);
    });

    test("semanticSearchEmbeddingBased (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = {
            system: { name: "ICD-10-CM", version: "2025" },
            results: [{ code: "E11.65", description: "Type 2 diabetes mellitus with hyperglycemia" }],
        };
        server
            .mockEndpoint()
            .get("/construe/codes/ICD-10-CM/search/semantic")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.construe.semanticSearchEmbeddingBased("ICD-10-CM", {
            text: "patient has trouble breathing at night and wakes up gasping",
            version: "version",
            limit: 1,
        });
        expect(response).toEqual({
            system: {
                name: "ICD-10-CM",
                version: "2025",
            },
            results: [
                {
                    code: "E11.65",
                    description: "Type 2 diabetes mellitus with hyperglycemia",
                },
            ],
        });
    });

    test("semanticSearchEmbeddingBased (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/construe/codes/codesystem/search/semantic")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.semanticSearchEmbeddingBased("codesystem", {
                text: "text",
            });
        }).rejects.toThrow(phenoml.construe.BadRequestError);
    });

    test("semanticSearchEmbeddingBased (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/construe/codes/codesystem/search/semantic")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.semanticSearchEmbeddingBased("codesystem", {
                text: "text",
            });
        }).rejects.toThrow(phenoml.construe.UnauthorizedError);
    });

    test("semanticSearchEmbeddingBased (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/construe/codes/codesystem/search/semantic")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.semanticSearchEmbeddingBased("codesystem", {
                text: "text",
            });
        }).rejects.toThrow(phenoml.construe.NotFoundError);
    });

    test("semanticSearchEmbeddingBased (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/construe/codes/codesystem/search/semantic")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.semanticSearchEmbeddingBased("codesystem", {
                text: "text",
            });
        }).rejects.toThrow(phenoml.construe.InternalServerError);
    });

    test("terminologyServerTextSearch (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = {
            system: { name: "ICD-10-CM", version: "2025" },
            results: [{ code: "E11.65", description: "Type 2 diabetes mellitus with hyperglycemia" }],
            found: 150,
        };
        server
            .mockEndpoint()
            .get("/construe/codes/ICD-10-CM/search/text")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.construe.terminologyServerTextSearch("ICD-10-CM", {
            q: "E11.65",
            version: "version",
            limit: 1,
        });
        expect(response).toEqual({
            system: {
                name: "ICD-10-CM",
                version: "2025",
            },
            results: [
                {
                    code: "E11.65",
                    description: "Type 2 diabetes mellitus with hyperglycemia",
                },
            ],
            found: 150,
        });
    });

    test("terminologyServerTextSearch (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/construe/codes/codesystem/search/text")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.terminologyServerTextSearch("codesystem", {
                q: "q",
            });
        }).rejects.toThrow(phenoml.construe.BadRequestError);
    });

    test("terminologyServerTextSearch (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/construe/codes/codesystem/search/text")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.terminologyServerTextSearch("codesystem", {
                q: "q",
            });
        }).rejects.toThrow(phenoml.construe.UnauthorizedError);
    });

    test("terminologyServerTextSearch (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/construe/codes/codesystem/search/text")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.terminologyServerTextSearch("codesystem", {
                q: "q",
            });
        }).rejects.toThrow(phenoml.construe.NotFoundError);
    });

    test("terminologyServerTextSearch (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/construe/codes/codesystem/search/text")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.terminologyServerTextSearch("codesystem", {
                q: "q",
            });
        }).rejects.toThrow(phenoml.construe.InternalServerError);
    });

    test("terminologyServerTextSearch (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/construe/codes/codesystem/search/text")
            .respondWith()
            .statusCode(501)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.terminologyServerTextSearch("codesystem", {
                q: "q",
            });
        }).rejects.toThrow(phenoml.construe.NotImplementedError);
    });

    test("terminologyServerTextSearch (7)", async () => {
        const server = mockServerPool.createServer();
        const client = new phenomlClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/construe/codes/codesystem/search/text")
            .respondWith()
            .statusCode(503)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.construe.terminologyServerTextSearch("codesystem", {
                q: "q",
            });
        }).rejects.toThrow(phenoml.construe.ServiceUnavailableError);
    });
});
