// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../BaseClient.js";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../BaseClient.js";
import { mergeHeaders } from "../../../../core/headers.js";
import * as core from "../../../../core/index.js";
import * as environments from "../../../../environments.js";
import { handleNonStatusCodeError } from "../../../../errors/handleNonStatusCodeError.js";
import * as errors from "../../../../errors/index.js";
import * as phenoml from "../../../index.js";

export declare namespace SummaryClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

export class SummaryClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<SummaryClient.Options>;

    constructor(options: SummaryClient.Options) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    /**
     * Retrieves all summary templates for the authenticated user
     *
     * @param {SummaryClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link phenoml.summary.UnauthorizedError}
     * @throws {@link phenoml.summary.InternalServerError}
     *
     * @example
     *     await client.summary.listTemplates()
     */
    public listTemplates(
        requestOptions?: SummaryClient.RequestOptions,
    ): core.HttpResponsePromise<phenoml.summary.SummaryListTemplatesResponse> {
        return core.HttpResponsePromise.fromPromise(this.__listTemplates(requestOptions));
    }

    private async __listTemplates(
        requestOptions?: SummaryClient.RequestOptions,
    ): Promise<core.WithRawResponse<phenoml.summary.SummaryListTemplatesResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.phenomlEnvironment.Default,
                "fhir2summary/templates",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: _response.body as phenoml.summary.SummaryListTemplatesResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 401:
                    throw new phenoml.summary.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new phenoml.summary.InternalServerError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.phenomlError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/fhir2summary/templates");
    }

    /**
     * Creates a summary template from an example using LLM function calling
     *
     * @param {phenoml.summary.CreateSummaryTemplateRequest} request
     * @param {SummaryClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link phenoml.summary.BadRequestError}
     * @throws {@link phenoml.summary.UnauthorizedError}
     * @throws {@link phenoml.summary.InternalServerError}
     *
     * @example
     *     await client.summary.createTemplate({
     *         name: "name",
     *         example_summary: "Patient John Doe, age 45, presents with hypertension diagnosed on 2024-01-15.",
     *         target_resources: ["Patient", "Condition", "Observation"],
     *         mode: "mode"
     *     })
     */
    public createTemplate(
        request: phenoml.summary.CreateSummaryTemplateRequest,
        requestOptions?: SummaryClient.RequestOptions,
    ): core.HttpResponsePromise<phenoml.summary.CreateSummaryTemplateResponse> {
        return core.HttpResponsePromise.fromPromise(this.__createTemplate(request, requestOptions));
    }

    private async __createTemplate(
        request: phenoml.summary.CreateSummaryTemplateRequest,
        requestOptions?: SummaryClient.RequestOptions,
    ): Promise<core.WithRawResponse<phenoml.summary.CreateSummaryTemplateResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.phenomlEnvironment.Default,
                "fhir2summary/template",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: _response.body as phenoml.summary.CreateSummaryTemplateResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new phenoml.summary.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new phenoml.summary.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new phenoml.summary.InternalServerError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.phenomlError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/fhir2summary/template");
    }

    /**
     * Retrieves a specific summary template
     *
     * @param {string} id - Template ID
     * @param {SummaryClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link phenoml.summary.UnauthorizedError}
     * @throws {@link phenoml.summary.ForbiddenError}
     * @throws {@link phenoml.summary.NotFoundError}
     * @throws {@link phenoml.summary.InternalServerError}
     *
     * @example
     *     await client.summary.getTemplate("id")
     */
    public getTemplate(
        id: string,
        requestOptions?: SummaryClient.RequestOptions,
    ): core.HttpResponsePromise<phenoml.summary.SummaryGetTemplateResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getTemplate(id, requestOptions));
    }

    private async __getTemplate(
        id: string,
        requestOptions?: SummaryClient.RequestOptions,
    ): Promise<core.WithRawResponse<phenoml.summary.SummaryGetTemplateResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.phenomlEnvironment.Default,
                `fhir2summary/template/${core.url.encodePathParam(id)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: _response.body as phenoml.summary.SummaryGetTemplateResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 401:
                    throw new phenoml.summary.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new phenoml.summary.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new phenoml.summary.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new phenoml.summary.InternalServerError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.phenomlError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/fhir2summary/template/{id}");
    }

    /**
     * Updates an existing summary template
     *
     * @param {string} id - Template ID
     * @param {phenoml.summary.UpdateSummaryTemplateRequest} request
     * @param {SummaryClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link phenoml.summary.BadRequestError}
     * @throws {@link phenoml.summary.UnauthorizedError}
     * @throws {@link phenoml.summary.ForbiddenError}
     * @throws {@link phenoml.summary.NotFoundError}
     * @throws {@link phenoml.summary.InternalServerError}
     *
     * @example
     *     await client.summary.updateTemplate("id", {
     *         name: "name",
     *         template: "template",
     *         target_resources: ["target_resources"],
     *         mode: "mode"
     *     })
     */
    public updateTemplate(
        id: string,
        request: phenoml.summary.UpdateSummaryTemplateRequest,
        requestOptions?: SummaryClient.RequestOptions,
    ): core.HttpResponsePromise<phenoml.summary.SummaryUpdateTemplateResponse> {
        return core.HttpResponsePromise.fromPromise(this.__updateTemplate(id, request, requestOptions));
    }

    private async __updateTemplate(
        id: string,
        request: phenoml.summary.UpdateSummaryTemplateRequest,
        requestOptions?: SummaryClient.RequestOptions,
    ): Promise<core.WithRawResponse<phenoml.summary.SummaryUpdateTemplateResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.phenomlEnvironment.Default,
                `fhir2summary/template/${core.url.encodePathParam(id)}`,
            ),
            method: "PUT",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: _response.body as phenoml.summary.SummaryUpdateTemplateResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new phenoml.summary.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new phenoml.summary.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new phenoml.summary.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new phenoml.summary.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new phenoml.summary.InternalServerError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.phenomlError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "PUT", "/fhir2summary/template/{id}");
    }

    /**
     * Deletes a summary template
     *
     * @param {string} id - Template ID
     * @param {SummaryClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link phenoml.summary.UnauthorizedError}
     * @throws {@link phenoml.summary.ForbiddenError}
     * @throws {@link phenoml.summary.NotFoundError}
     * @throws {@link phenoml.summary.InternalServerError}
     *
     * @example
     *     await client.summary.deleteTemplate("id")
     */
    public deleteTemplate(
        id: string,
        requestOptions?: SummaryClient.RequestOptions,
    ): core.HttpResponsePromise<phenoml.summary.SummaryDeleteTemplateResponse> {
        return core.HttpResponsePromise.fromPromise(this.__deleteTemplate(id, requestOptions));
    }

    private async __deleteTemplate(
        id: string,
        requestOptions?: SummaryClient.RequestOptions,
    ): Promise<core.WithRawResponse<phenoml.summary.SummaryDeleteTemplateResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.phenomlEnvironment.Default,
                `fhir2summary/template/${core.url.encodePathParam(id)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: _response.body as phenoml.summary.SummaryDeleteTemplateResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 401:
                    throw new phenoml.summary.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new phenoml.summary.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new phenoml.summary.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new phenoml.summary.InternalServerError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.phenomlError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "DELETE",
            "/fhir2summary/template/{id}",
        );
    }

    /**
     * Creates a summary from FHIR resources using one of three modes:
     * - **narrative**: Uses a template to substitute FHIR data into placeholders (requires template_id)
     * - **flatten**: Flattens FHIR resources into a searchable format for RAG/search (no template needed)
     * - **ips**: Generates an International Patient Summary (IPS) narrative per ISO 27269/HL7 FHIR IPS IG. Requires a Bundle with exactly one Patient resource (returns 400 error if no Patient or multiple Patients are present). Automatically filters resources to those referencing the patient and generates sections for allergies, medications, problems, immunizations, procedures, and vital signs.
     *
     * @param {phenoml.summary.CreateSummaryRequest} request
     * @param {SummaryClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link phenoml.summary.BadRequestError}
     * @throws {@link phenoml.summary.UnauthorizedError}
     * @throws {@link phenoml.summary.ForbiddenError}
     * @throws {@link phenoml.summary.NotFoundError}
     * @throws {@link phenoml.summary.InternalServerError}
     *
     * @example
     *     await client.summary.create({
     *         fhir_resources: {
     *             resourceType: "resourceType"
     *         }
     *     })
     */
    public create(
        request: phenoml.summary.CreateSummaryRequest,
        requestOptions?: SummaryClient.RequestOptions,
    ): core.HttpResponsePromise<phenoml.summary.CreateSummaryResponse> {
        return core.HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
    }

    private async __create(
        request: phenoml.summary.CreateSummaryRequest,
        requestOptions?: SummaryClient.RequestOptions,
    ): Promise<core.WithRawResponse<phenoml.summary.CreateSummaryResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.phenomlEnvironment.Default,
                "fhir2summary/create",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: _response.body as phenoml.summary.CreateSummaryResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new phenoml.summary.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new phenoml.summary.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new phenoml.summary.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new phenoml.summary.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new phenoml.summary.InternalServerError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.phenomlError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/fhir2summary/create");
    }
}
