// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../BaseClient.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import * as core from "../../../../core/index.js";
import * as environments from "../../../../environments.js";
import * as errors from "../../../../errors/index.js";
import * as phenoml from "../../../index.js";

export declare namespace Summary {
    export interface Options extends BaseClientOptions {}

    export interface RequestOptions extends BaseRequestOptions {}
}

export class Summary {
    protected readonly _options: Summary.Options;

    constructor(_options: Summary.Options) {
        this._options = _options;
    }

    /**
     * Retrieves all summary templates for the authenticated user
     *
     * @param {Summary.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link phenoml.summary.UnauthorizedError}
     * @throws {@link phenoml.summary.InternalServerError}
     *
     * @example
     *     await client.summary.listTemplates()
     */
    public listTemplates(
        requestOptions?: Summary.RequestOptions,
    ): core.HttpResponsePromise<phenoml.summary.SummaryListTemplatesResponse> {
        return core.HttpResponsePromise.fromPromise(this.__listTemplates(requestOptions));
    }

    private async __listTemplates(
        requestOptions?: Summary.RequestOptions,
    ): Promise<core.WithRawResponse<phenoml.summary.SummaryListTemplatesResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.phenomlEnvironment.Default,
                "fhir2summary/templates",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
        });
        if (_response.ok) {
            return {
                data: _response.body as phenoml.summary.SummaryListTemplatesResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 401:
                    throw new phenoml.summary.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new phenoml.summary.InternalServerError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.phenomlError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.phenomlError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.phenomlTimeoutError("Timeout exceeded when calling GET /fhir2summary/templates.");
            case "unknown":
                throw new errors.phenomlError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Creates a summary template from an example using LLM function calling
     *
     * @param {phenoml.summary.CreateSummaryTemplateRequest} request
     * @param {Summary.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link phenoml.summary.BadRequestError}
     * @throws {@link phenoml.summary.UnauthorizedError}
     * @throws {@link phenoml.summary.InternalServerError}
     *
     * @example
     *     await client.summary.createTemplate({
     *         name: "name",
     *         example_summary: "Patient John Doe, age 45, presents with hypertension diagnosed on 2024-01-15.",
     *         target_resources: ["Patient", "Condition", "Observation"],
     *         mode: "mode"
     *     })
     */
    public createTemplate(
        request: phenoml.summary.CreateSummaryTemplateRequest,
        requestOptions?: Summary.RequestOptions,
    ): core.HttpResponsePromise<phenoml.summary.CreateSummaryTemplateResponse> {
        return core.HttpResponsePromise.fromPromise(this.__createTemplate(request, requestOptions));
    }

    private async __createTemplate(
        request: phenoml.summary.CreateSummaryTemplateRequest,
        requestOptions?: Summary.RequestOptions,
    ): Promise<core.WithRawResponse<phenoml.summary.CreateSummaryTemplateResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.phenomlEnvironment.Default,
                "fhir2summary/template",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
        });
        if (_response.ok) {
            return {
                data: _response.body as phenoml.summary.CreateSummaryTemplateResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new phenoml.summary.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new phenoml.summary.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new phenoml.summary.InternalServerError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.phenomlError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.phenomlError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.phenomlTimeoutError("Timeout exceeded when calling POST /fhir2summary/template.");
            case "unknown":
                throw new errors.phenomlError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Retrieves a specific summary template
     *
     * @param {string} id - Template ID
     * @param {Summary.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link phenoml.summary.UnauthorizedError}
     * @throws {@link phenoml.summary.ForbiddenError}
     * @throws {@link phenoml.summary.NotFoundError}
     * @throws {@link phenoml.summary.InternalServerError}
     *
     * @example
     *     await client.summary.getTemplate("id")
     */
    public getTemplate(
        id: string,
        requestOptions?: Summary.RequestOptions,
    ): core.HttpResponsePromise<phenoml.summary.SummaryGetTemplateResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getTemplate(id, requestOptions));
    }

    private async __getTemplate(
        id: string,
        requestOptions?: Summary.RequestOptions,
    ): Promise<core.WithRawResponse<phenoml.summary.SummaryGetTemplateResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.phenomlEnvironment.Default,
                `fhir2summary/template/${core.url.encodePathParam(id)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
        });
        if (_response.ok) {
            return {
                data: _response.body as phenoml.summary.SummaryGetTemplateResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 401:
                    throw new phenoml.summary.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new phenoml.summary.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new phenoml.summary.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new phenoml.summary.InternalServerError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.phenomlError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.phenomlError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.phenomlTimeoutError("Timeout exceeded when calling GET /fhir2summary/template/{id}.");
            case "unknown":
                throw new errors.phenomlError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Updates an existing summary template
     *
     * @param {string} id - Template ID
     * @param {phenoml.summary.UpdateSummaryTemplateRequest} request
     * @param {Summary.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link phenoml.summary.BadRequestError}
     * @throws {@link phenoml.summary.UnauthorizedError}
     * @throws {@link phenoml.summary.ForbiddenError}
     * @throws {@link phenoml.summary.NotFoundError}
     * @throws {@link phenoml.summary.InternalServerError}
     *
     * @example
     *     await client.summary.updateTemplate("id", {
     *         name: "name",
     *         template: "template",
     *         target_resources: ["target_resources"],
     *         mode: "mode"
     *     })
     */
    public updateTemplate(
        id: string,
        request: phenoml.summary.UpdateSummaryTemplateRequest,
        requestOptions?: Summary.RequestOptions,
    ): core.HttpResponsePromise<phenoml.summary.SummaryUpdateTemplateResponse> {
        return core.HttpResponsePromise.fromPromise(this.__updateTemplate(id, request, requestOptions));
    }

    private async __updateTemplate(
        id: string,
        request: phenoml.summary.UpdateSummaryTemplateRequest,
        requestOptions?: Summary.RequestOptions,
    ): Promise<core.WithRawResponse<phenoml.summary.SummaryUpdateTemplateResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.phenomlEnvironment.Default,
                `fhir2summary/template/${core.url.encodePathParam(id)}`,
            ),
            method: "PUT",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
        });
        if (_response.ok) {
            return {
                data: _response.body as phenoml.summary.SummaryUpdateTemplateResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new phenoml.summary.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new phenoml.summary.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new phenoml.summary.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new phenoml.summary.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new phenoml.summary.InternalServerError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.phenomlError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.phenomlError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.phenomlTimeoutError("Timeout exceeded when calling PUT /fhir2summary/template/{id}.");
            case "unknown":
                throw new errors.phenomlError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Deletes a summary template
     *
     * @param {string} id - Template ID
     * @param {Summary.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link phenoml.summary.UnauthorizedError}
     * @throws {@link phenoml.summary.ForbiddenError}
     * @throws {@link phenoml.summary.NotFoundError}
     * @throws {@link phenoml.summary.InternalServerError}
     *
     * @example
     *     await client.summary.deleteTemplate("id")
     */
    public deleteTemplate(
        id: string,
        requestOptions?: Summary.RequestOptions,
    ): core.HttpResponsePromise<phenoml.summary.SummaryDeleteTemplateResponse> {
        return core.HttpResponsePromise.fromPromise(this.__deleteTemplate(id, requestOptions));
    }

    private async __deleteTemplate(
        id: string,
        requestOptions?: Summary.RequestOptions,
    ): Promise<core.WithRawResponse<phenoml.summary.SummaryDeleteTemplateResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.phenomlEnvironment.Default,
                `fhir2summary/template/${core.url.encodePathParam(id)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
        });
        if (_response.ok) {
            return {
                data: _response.body as phenoml.summary.SummaryDeleteTemplateResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 401:
                    throw new phenoml.summary.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new phenoml.summary.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new phenoml.summary.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new phenoml.summary.InternalServerError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.phenomlError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.phenomlError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.phenomlTimeoutError(
                    "Timeout exceeded when calling DELETE /fhir2summary/template/{id}.",
                );
            case "unknown":
                throw new errors.phenomlError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Creates a summary from FHIR resources using one of three modes:
     * - **narrative**: Uses a template to substitute FHIR data into placeholders (requires template_id)
     * - **flatten**: Flattens FHIR resources into a searchable format for RAG/search (no template needed)
     * - **ips**: Generates an International Patient Summary (IPS) narrative per ISO 27269/HL7 FHIR IPS IG. Requires a Bundle with exactly one Patient resource (returns 400 error if no Patient or multiple Patients are present). Automatically filters resources to those referencing the patient and generates sections for allergies, medications, problems, immunizations, procedures, and vital signs.
     *
     * @param {phenoml.summary.CreateSummaryRequest} request
     * @param {Summary.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link phenoml.summary.BadRequestError}
     * @throws {@link phenoml.summary.UnauthorizedError}
     * @throws {@link phenoml.summary.ForbiddenError}
     * @throws {@link phenoml.summary.NotFoundError}
     * @throws {@link phenoml.summary.InternalServerError}
     *
     * @example
     *     await client.summary.create({
     *         fhir_resources: {
     *             resourceType: "resourceType"
     *         }
     *     })
     */
    public create(
        request: phenoml.summary.CreateSummaryRequest,
        requestOptions?: Summary.RequestOptions,
    ): core.HttpResponsePromise<phenoml.summary.CreateSummaryResponse> {
        return core.HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
    }

    private async __create(
        request: phenoml.summary.CreateSummaryRequest,
        requestOptions?: Summary.RequestOptions,
    ): Promise<core.WithRawResponse<phenoml.summary.CreateSummaryResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.phenomlEnvironment.Default,
                "fhir2summary/create",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
        });
        if (_response.ok) {
            return {
                data: _response.body as phenoml.summary.CreateSummaryResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new phenoml.summary.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new phenoml.summary.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 403:
                    throw new phenoml.summary.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new phenoml.summary.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new phenoml.summary.InternalServerError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.phenomlError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.phenomlError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.phenomlTimeoutError("Timeout exceeded when calling POST /fhir2summary/create.");
            case "unknown":
                throw new errors.phenomlError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getAuthorizationHeader(): Promise<string> {
        return `Bearer ${await core.Supplier.get(this._options.token)}`;
    }
}
