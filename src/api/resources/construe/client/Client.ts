// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../BaseClient.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import * as core from "../../../../core/index.js";
import * as environments from "../../../../environments.js";
import * as errors from "../../../../errors/index.js";
import * as phenoml from "../../../index.js";

export declare namespace Construe {
    export interface Options extends BaseClientOptions {}

    export interface RequestOptions extends BaseRequestOptions {}
}

export class Construe {
    protected readonly _options: Construe.Options;

    constructor(_options: Construe.Options) {
        this._options = _options;
    }

    /**
     * Upload a custom medical code system with codes and descriptions for use in code extraction. Requires a paid plan.
     * Returns 202 immediately; embedding generation runs asynchronously. Poll
     * GET /construe/codes/systems/{codesystem}?version={version} to check when status
     * transitions from "processing" to "ready" or "failed".
     *
     * @param {phenoml.construe.UploadRequest} request
     * @param {Construe.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link phenoml.construe.BadRequestError}
     * @throws {@link phenoml.construe.UnauthorizedError}
     * @throws {@link phenoml.construe.ForbiddenError}
     * @throws {@link phenoml.construe.ConflictError}
     * @throws {@link phenoml.construe.FailedDependencyError}
     * @throws {@link phenoml.construe.InternalServerError}
     *
     * @example
     *     await client.construe.uploadCodeSystem({
     *         name: "CUSTOM_CODES",
     *         version: "1.0",
     *         format: "csv"
     *     })
     */
    public uploadCodeSystem(
        request: phenoml.construe.UploadRequest,
        requestOptions?: Construe.RequestOptions,
    ): core.HttpResponsePromise<phenoml.construe.ConstrueUploadCodeSystemResponse> {
        return core.HttpResponsePromise.fromPromise(this.__uploadCodeSystem(request, requestOptions));
    }

    private async __uploadCodeSystem(
        request: phenoml.construe.UploadRequest,
        requestOptions?: Construe.RequestOptions,
    ): Promise<core.WithRawResponse<phenoml.construe.ConstrueUploadCodeSystemResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.phenomlEnvironment.Default,
                "construe/upload",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as phenoml.construe.ConstrueUploadCodeSystemResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new phenoml.construe.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new phenoml.construe.UnauthorizedError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                case 403:
                    throw new phenoml.construe.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 409:
                    throw new phenoml.construe.ConflictError(_response.error.body as unknown, _response.rawResponse);
                case 424:
                    throw new phenoml.construe.FailedDependencyError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                case 500:
                    throw new phenoml.construe.InternalServerError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.phenomlError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.phenomlError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.phenomlTimeoutError("Timeout exceeded when calling POST /construe/upload.");
            case "unknown":
                throw new errors.phenomlError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Converts natural language text into structured medical codes.
     *
     * Usage of CPT is subject to AMA requirements: see PhenoML Terms of Service.
     *
     * @param {phenoml.construe.ExtractRequest} request
     * @param {Construe.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link phenoml.construe.BadRequestError}
     * @throws {@link phenoml.construe.UnauthorizedError}
     * @throws {@link phenoml.construe.FailedDependencyError}
     * @throws {@link phenoml.construe.InternalServerError}
     *
     * @example
     *     await client.construe.extractCodes({
     *         text: "Patient is a 14-year-old female, previously healthy, who is here for evaluation of abnormal renal ultrasound with atrophic right kidney"
     *     })
     */
    public extractCodes(
        request: phenoml.construe.ExtractRequest,
        requestOptions?: Construe.RequestOptions,
    ): core.HttpResponsePromise<phenoml.construe.ExtractCodesResult> {
        return core.HttpResponsePromise.fromPromise(this.__extractCodes(request, requestOptions));
    }

    private async __extractCodes(
        request: phenoml.construe.ExtractRequest,
        requestOptions?: Construe.RequestOptions,
    ): Promise<core.WithRawResponse<phenoml.construe.ExtractCodesResult>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.phenomlEnvironment.Default,
                "construe/extract",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as phenoml.construe.ExtractCodesResult, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new phenoml.construe.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new phenoml.construe.UnauthorizedError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                case 424:
                    throw new phenoml.construe.FailedDependencyError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                case 500:
                    throw new phenoml.construe.InternalServerError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.phenomlError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.phenomlError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.phenomlTimeoutError("Timeout exceeded when calling POST /construe/extract.");
            case "unknown":
                throw new errors.phenomlError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Returns the terminology server's catalog of available code systems, including both built-in standard terminologies and custom uploaded systems.
     *
     * @param {Construe.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link phenoml.construe.UnauthorizedError}
     * @throws {@link phenoml.construe.InternalServerError}
     *
     * @example
     *     await client.construe.listAvailableCodeSystems()
     */
    public listAvailableCodeSystems(
        requestOptions?: Construe.RequestOptions,
    ): core.HttpResponsePromise<phenoml.construe.ListCodeSystemsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__listAvailableCodeSystems(requestOptions));
    }

    private async __listAvailableCodeSystems(
        requestOptions?: Construe.RequestOptions,
    ): Promise<core.WithRawResponse<phenoml.construe.ListCodeSystemsResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.phenomlEnvironment.Default,
                "construe/codes/systems",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as phenoml.construe.ListCodeSystemsResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 401:
                    throw new phenoml.construe.UnauthorizedError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                case 500:
                    throw new phenoml.construe.InternalServerError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.phenomlError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.phenomlError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.phenomlTimeoutError("Timeout exceeded when calling GET /construe/codes/systems.");
            case "unknown":
                throw new errors.phenomlError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Returns full metadata for a single code system, including timestamps and builtin status.
     *
     * @param {string} codesystem - Code system name (e.g., "ICD-10-CM", "SNOMED_CT_US_LITE")
     * @param {phenoml.construe.GetConstrueCodesSystemsCodesystemRequest} request
     * @param {Construe.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link phenoml.construe.BadRequestError}
     * @throws {@link phenoml.construe.UnauthorizedError}
     * @throws {@link phenoml.construe.NotFoundError}
     * @throws {@link phenoml.construe.InternalServerError}
     *
     * @example
     *     await client.construe.getCodeSystemDetail("ICD-10-CM", {
     *         version: "2025"
     *     })
     */
    public getCodeSystemDetail(
        codesystem: string,
        request: phenoml.construe.GetConstrueCodesSystemsCodesystemRequest = {},
        requestOptions?: Construe.RequestOptions,
    ): core.HttpResponsePromise<phenoml.construe.GetCodeSystemDetailResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getCodeSystemDetail(codesystem, request, requestOptions));
    }

    private async __getCodeSystemDetail(
        codesystem: string,
        request: phenoml.construe.GetConstrueCodesSystemsCodesystemRequest = {},
        requestOptions?: Construe.RequestOptions,
    ): Promise<core.WithRawResponse<phenoml.construe.GetCodeSystemDetailResponse>> {
        const { version } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (version != null) {
            _queryParams.version = version;
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.phenomlEnvironment.Default,
                `construe/codes/systems/${core.url.encodePathParam(codesystem)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as phenoml.construe.GetCodeSystemDetailResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new phenoml.construe.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new phenoml.construe.UnauthorizedError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                case 404:
                    throw new phenoml.construe.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new phenoml.construe.InternalServerError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.phenomlError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.phenomlError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.phenomlTimeoutError(
                    "Timeout exceeded when calling GET /construe/codes/systems/{codesystem}.",
                );
            case "unknown":
                throw new errors.phenomlError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Deletes a custom (non-builtin) code system and all its codes. Builtin systems cannot be deleted.
     * Only available on dedicated instances. Large systems may take up to a minute to delete.
     *
     * @param {string} codesystem - Code system name
     * @param {phenoml.construe.DeleteConstrueCodesSystemsCodesystemRequest} request
     * @param {Construe.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link phenoml.construe.BadRequestError}
     * @throws {@link phenoml.construe.UnauthorizedError}
     * @throws {@link phenoml.construe.ForbiddenError}
     * @throws {@link phenoml.construe.NotFoundError}
     * @throws {@link phenoml.construe.InternalServerError}
     *
     * @example
     *     await client.construe.deleteCustomCodeSystem("CUSTOM_CODES", {
     *         version: "version"
     *     })
     */
    public deleteCustomCodeSystem(
        codesystem: string,
        request: phenoml.construe.DeleteConstrueCodesSystemsCodesystemRequest = {},
        requestOptions?: Construe.RequestOptions,
    ): core.HttpResponsePromise<phenoml.construe.DeleteCodeSystemResponse> {
        return core.HttpResponsePromise.fromPromise(this.__deleteCustomCodeSystem(codesystem, request, requestOptions));
    }

    private async __deleteCustomCodeSystem(
        codesystem: string,
        request: phenoml.construe.DeleteConstrueCodesSystemsCodesystemRequest = {},
        requestOptions?: Construe.RequestOptions,
    ): Promise<core.WithRawResponse<phenoml.construe.DeleteCodeSystemResponse>> {
        const { version } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (version != null) {
            _queryParams.version = version;
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.phenomlEnvironment.Default,
                `construe/codes/systems/${core.url.encodePathParam(codesystem)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as phenoml.construe.DeleteCodeSystemResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new phenoml.construe.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new phenoml.construe.UnauthorizedError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                case 403:
                    throw new phenoml.construe.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new phenoml.construe.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new phenoml.construe.InternalServerError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.phenomlError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.phenomlError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.phenomlTimeoutError(
                    "Timeout exceeded when calling DELETE /construe/codes/systems/{codesystem}.",
                );
            case "unknown":
                throw new errors.phenomlError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Exports a custom (non-builtin) code system as a JSON file compatible with the upload format.
     * The exported file can be re-uploaded directly via POST /construe/upload with format "json".
     * Only available on dedicated instances. Builtin systems cannot be exported.
     *
     * @param {string} codesystem - Code system name
     * @param {phenoml.construe.GetConstrueCodesSystemsCodesystemExportRequest} request
     * @param {Construe.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link phenoml.construe.BadRequestError}
     * @throws {@link phenoml.construe.UnauthorizedError}
     * @throws {@link phenoml.construe.ForbiddenError}
     * @throws {@link phenoml.construe.NotFoundError}
     * @throws {@link phenoml.construe.ConflictError}
     * @throws {@link phenoml.construe.FailedDependencyError}
     * @throws {@link phenoml.construe.InternalServerError}
     *
     * @example
     *     await client.construe.exportCustomCodeSystem("CUSTOM_CODES", {
     *         version: "version"
     *     })
     */
    public exportCustomCodeSystem(
        codesystem: string,
        request: phenoml.construe.GetConstrueCodesSystemsCodesystemExportRequest = {},
        requestOptions?: Construe.RequestOptions,
    ): core.HttpResponsePromise<phenoml.construe.ExportCodeSystemResponse> {
        return core.HttpResponsePromise.fromPromise(this.__exportCustomCodeSystem(codesystem, request, requestOptions));
    }

    private async __exportCustomCodeSystem(
        codesystem: string,
        request: phenoml.construe.GetConstrueCodesSystemsCodesystemExportRequest = {},
        requestOptions?: Construe.RequestOptions,
    ): Promise<core.WithRawResponse<phenoml.construe.ExportCodeSystemResponse>> {
        const { version } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (version != null) {
            _queryParams.version = version;
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.phenomlEnvironment.Default,
                `construe/codes/systems/${core.url.encodePathParam(codesystem)}/export`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as phenoml.construe.ExportCodeSystemResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new phenoml.construe.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new phenoml.construe.UnauthorizedError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                case 403:
                    throw new phenoml.construe.ForbiddenError(_response.error.body as unknown, _response.rawResponse);
                case 404:
                    throw new phenoml.construe.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 409:
                    throw new phenoml.construe.ConflictError(_response.error.body as unknown, _response.rawResponse);
                case 424:
                    throw new phenoml.construe.FailedDependencyError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                case 500:
                    throw new phenoml.construe.InternalServerError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.phenomlError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.phenomlError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.phenomlTimeoutError(
                    "Timeout exceeded when calling GET /construe/codes/systems/{codesystem}/export.",
                );
            case "unknown":
                throw new errors.phenomlError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Returns a paginated list of all codes in the specified code system from the terminology server.
     *
     * Usage of CPT is subject to AMA requirements: see PhenoML Terms of Service.
     *
     * @param {string} codesystem - Code system name (e.g., "ICD-10-CM", "SNOMED_CT_US_LITE")
     * @param {phenoml.construe.GetConstrueCodesCodesystemRequest} request
     * @param {Construe.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link phenoml.construe.BadRequestError}
     * @throws {@link phenoml.construe.UnauthorizedError}
     * @throws {@link phenoml.construe.NotFoundError}
     * @throws {@link phenoml.construe.InternalServerError}
     *
     * @example
     *     await client.construe.listCodesInACodeSystem("ICD-10-CM", {
     *         version: "2025",
     *         cursor: "cursor",
     *         limit: 1
     *     })
     */
    public listCodesInACodeSystem(
        codesystem: string,
        request: phenoml.construe.GetConstrueCodesCodesystemRequest = {},
        requestOptions?: Construe.RequestOptions,
    ): core.HttpResponsePromise<phenoml.construe.ListCodesResponse> {
        return core.HttpResponsePromise.fromPromise(this.__listCodesInACodeSystem(codesystem, request, requestOptions));
    }

    private async __listCodesInACodeSystem(
        codesystem: string,
        request: phenoml.construe.GetConstrueCodesCodesystemRequest = {},
        requestOptions?: Construe.RequestOptions,
    ): Promise<core.WithRawResponse<phenoml.construe.ListCodesResponse>> {
        const { version, cursor, limit } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (version != null) {
            _queryParams.version = version;
        }

        if (cursor != null) {
            _queryParams.cursor = cursor;
        }

        if (limit != null) {
            _queryParams.limit = limit.toString();
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.phenomlEnvironment.Default,
                `construe/codes/${core.url.encodePathParam(codesystem)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as phenoml.construe.ListCodesResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new phenoml.construe.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new phenoml.construe.UnauthorizedError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                case 404:
                    throw new phenoml.construe.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new phenoml.construe.InternalServerError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.phenomlError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.phenomlError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.phenomlTimeoutError("Timeout exceeded when calling GET /construe/codes/{codesystem}.");
            case "unknown":
                throw new errors.phenomlError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Looks up a specific code in the terminology server and returns its details.
     *
     * Usage of CPT is subject to AMA requirements: see PhenoML Terms of Service.
     *
     * @param {string} codesystem - Code system name
     * @param {string} codeId - The code identifier
     * @param {phenoml.construe.GetConstrueCodesCodesystemCodeIdRequest} request
     * @param {Construe.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link phenoml.construe.BadRequestError}
     * @throws {@link phenoml.construe.UnauthorizedError}
     * @throws {@link phenoml.construe.NotFoundError}
     * @throws {@link phenoml.construe.InternalServerError}
     *
     * @example
     *     await client.construe.getASpecificCode("ICD-10-CM", "E11.65", {
     *         version: "version"
     *     })
     */
    public getASpecificCode(
        codesystem: string,
        codeId: string,
        request: phenoml.construe.GetConstrueCodesCodesystemCodeIdRequest = {},
        requestOptions?: Construe.RequestOptions,
    ): core.HttpResponsePromise<phenoml.construe.GetCodeResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__getASpecificCode(codesystem, codeId, request, requestOptions),
        );
    }

    private async __getASpecificCode(
        codesystem: string,
        codeId: string,
        request: phenoml.construe.GetConstrueCodesCodesystemCodeIdRequest = {},
        requestOptions?: Construe.RequestOptions,
    ): Promise<core.WithRawResponse<phenoml.construe.GetCodeResponse>> {
        const { version } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (version != null) {
            _queryParams.version = version;
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.phenomlEnvironment.Default,
                `construe/codes/${core.url.encodePathParam(codesystem)}/${core.url.encodePathParam(codeId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as phenoml.construe.GetCodeResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new phenoml.construe.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new phenoml.construe.UnauthorizedError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                case 404:
                    throw new phenoml.construe.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new phenoml.construe.InternalServerError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.phenomlError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.phenomlError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.phenomlTimeoutError(
                    "Timeout exceeded when calling GET /construe/codes/{codesystem}/{codeID}.",
                );
            case "unknown":
                throw new errors.phenomlError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Performs semantic similarity search using vector embeddings.
     *
     * **Availability**: This endpoint works for both **built-in and custom** code systems.
     *
     * **When to use**: Best for natural language queries where you want to find conceptually
     * related codes, even when different terminology is used. The search understands meaning,
     * not just keywords.
     *
     * **Examples**:
     * - Query "trouble breathing at night" finds codes like "Sleep apnea", "Orthopnea",
     *   "Nocturnal dyspnea" â€” semantically related but no exact keyword matches
     * - Query "heart problems" finds "Myocardial infarction", "Cardiac arrest", "Arrhythmia"
     *
     * **Trade-offs**: Slower than text search (requires embedding generation), but finds
     * conceptually similar results that keyword search would miss.
     *
     * See also: `/search/text` for faster keyword-based lookup with typo tolerance.
     *
     * Usage of CPT is subject to AMA requirements: see PhenoML Terms of Service.
     *
     * @param {string} codesystem - Code system name
     * @param {phenoml.construe.GetConstrueCodesCodesystemSearchSemanticRequest} request
     * @param {Construe.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link phenoml.construe.BadRequestError}
     * @throws {@link phenoml.construe.UnauthorizedError}
     * @throws {@link phenoml.construe.NotFoundError}
     * @throws {@link phenoml.construe.InternalServerError}
     *
     * @example
     *     await client.construe.semanticSearchEmbeddingBased("ICD-10-CM", {
     *         text: "patient has trouble breathing at night and wakes up gasping",
     *         version: "version",
     *         limit: 1
     *     })
     */
    public semanticSearchEmbeddingBased(
        codesystem: string,
        request: phenoml.construe.GetConstrueCodesCodesystemSearchSemanticRequest,
        requestOptions?: Construe.RequestOptions,
    ): core.HttpResponsePromise<phenoml.construe.SemanticSearchResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__semanticSearchEmbeddingBased(codesystem, request, requestOptions),
        );
    }

    private async __semanticSearchEmbeddingBased(
        codesystem: string,
        request: phenoml.construe.GetConstrueCodesCodesystemSearchSemanticRequest,
        requestOptions?: Construe.RequestOptions,
    ): Promise<core.WithRawResponse<phenoml.construe.SemanticSearchResponse>> {
        const { text, version, limit } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams.text = text;
        if (version != null) {
            _queryParams.version = version;
        }

        if (limit != null) {
            _queryParams.limit = limit.toString();
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.phenomlEnvironment.Default,
                `construe/codes/${core.url.encodePathParam(codesystem)}/search/semantic`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as phenoml.construe.SemanticSearchResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new phenoml.construe.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new phenoml.construe.UnauthorizedError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                case 404:
                    throw new phenoml.construe.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new phenoml.construe.InternalServerError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.phenomlError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.phenomlError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.phenomlTimeoutError(
                    "Timeout exceeded when calling GET /construe/codes/{codesystem}/search/semantic.",
                );
            case "unknown":
                throw new errors.phenomlError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Performs fast full-text search over code IDs and descriptions.
     *
     * **Availability**: This endpoint is only available for **built-in code systems**.
     * Custom code systems uploaded via `/construe/upload` are not indexed for full-text search
     * and will return empty results. Use `/search/semantic` to search custom code systems.
     *
     * **When to use**: Best for autocomplete UIs, code lookup, or when users know part of
     * the code ID or specific keywords. Fast response times suitable for typeahead interfaces.
     *
     * **Features**:
     * - Substring matching on code IDs (e.g., "11.65" finds "E11.65")
     * - Typo tolerance on descriptions (not on code IDs)
     * - Fast response times (~10-50ms)
     *
     * **Examples**:
     * - Query "E11" finds all codes starting with E11 (diabetes codes)
     * - Query "diabtes" (typo) still finds "diabetes" codes
     *
     * **Trade-offs**: Faster than semantic search, but only matches keywords/substrings.
     * Won't find conceptually related codes with different terminology.
     *
     * See also: `/search/semantic` for finding conceptually similar codes.
     *
     * Usage of CPT is subject to AMA requirements: see PhenoML Terms of Service.
     *
     * @param {string} codesystem - Code system name
     * @param {phenoml.construe.GetConstrueCodesCodesystemSearchTextRequest} request
     * @param {Construe.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link phenoml.construe.BadRequestError}
     * @throws {@link phenoml.construe.UnauthorizedError}
     * @throws {@link phenoml.construe.NotFoundError}
     * @throws {@link phenoml.construe.InternalServerError}
     * @throws {@link phenoml.construe.NotImplementedError}
     * @throws {@link phenoml.construe.ServiceUnavailableError}
     *
     * @example
     *     await client.construe.terminologyServerTextSearch("ICD-10-CM", {
     *         q: "E11.65",
     *         version: "version",
     *         limit: 1
     *     })
     */
    public terminologyServerTextSearch(
        codesystem: string,
        request: phenoml.construe.GetConstrueCodesCodesystemSearchTextRequest,
        requestOptions?: Construe.RequestOptions,
    ): core.HttpResponsePromise<phenoml.construe.TextSearchResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__terminologyServerTextSearch(codesystem, request, requestOptions),
        );
    }

    private async __terminologyServerTextSearch(
        codesystem: string,
        request: phenoml.construe.GetConstrueCodesCodesystemSearchTextRequest,
        requestOptions?: Construe.RequestOptions,
    ): Promise<core.WithRawResponse<phenoml.construe.TextSearchResponse>> {
        const { q, version, limit } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams.q = q;
        if (version != null) {
            _queryParams.version = version;
        }

        if (limit != null) {
            _queryParams.limit = limit.toString();
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.phenomlEnvironment.Default,
                `construe/codes/${core.url.encodePathParam(codesystem)}/search/text`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as phenoml.construe.TextSearchResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new phenoml.construe.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new phenoml.construe.UnauthorizedError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                case 404:
                    throw new phenoml.construe.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new phenoml.construe.InternalServerError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                case 501:
                    throw new phenoml.construe.NotImplementedError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                case 503:
                    throw new phenoml.construe.ServiceUnavailableError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.phenomlError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.phenomlError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.phenomlTimeoutError(
                    "Timeout exceeded when calling GET /construe/codes/{codesystem}/search/text.",
                );
            case "unknown":
                throw new errors.phenomlError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getAuthorizationHeader(): Promise<string> {
        return `Bearer ${await core.Supplier.get(this._options.token)}`;
    }
}
